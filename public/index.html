<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar Analysis Tool v3.1</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .input-section {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr;
            gap: 15px;
            align-items: end;
            margin-bottom: 20px;
        }
        .input-group {
            display: flex;
            flex-direction: column;
        }
        label {
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        input[type="text"], input[type="number"] {
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        button {
            background-color: #007bff;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            height: fit-content;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
        }
        .status.success { background-color: #d4edda; color: #155724; }
        .status.error { background-color: #f8d7da; color: #721c24; }
        .status.info { background-color: #d1ecf1; color: #0c5460; }
        .results {
            display: none;
            margin-top: 20px;
        }
        .result-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .result-card {
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f8f9fa;
        }
        .result-card h3 {
            margin-top: 0;
            color: #007bff;
        }
        .metric {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
        }
        .metric-label {
            font-weight: bold;
        }
        .imagery-section {
            grid-column: 1 / -1;
            text-align: center;
        }
        .imagery-section img {
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin: 10px;
        }
        .loading {
            text-align: center;
            padding: 20px;
        }
        .spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .hidden { display: none; }
        @media (max-width: 768px) {
            .input-section {
                grid-template-columns: 1fr;
            }
            .result-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŒž Solar Analysis Tool <span style="font-size: 14px; color: #666;">[v3.1]</span></h1>

        <div class="input-section">
            <div class="input-group">
                <label for="address-input">Address</label>
                <input type="text" id="address-input" placeholder="Enter street address" />
            </div>
            <div class="input-group">
                <label for="panel-power">Panel Power (W)</label>
                <input type="number" id="panel-power" value="620" min="100" max="1000" />
            </div>
            <div class="input-group">
                <label for="panel-width">Panel Width (mm)</label>
                <input type="number" id="panel-width" value="1134" min="500" max="3000" step="1" />
            </div>
        </div>

        <div class="input-section">
            <div class="input-group">
                <label for="panel-height">Panel Height (mm)</label>
                <input type="number" id="panel-height" value="2278" min="500" max="3000" step="1" />
            </div>
            <div></div>
            <button id="analyze-btn" onclick="analyzeSolar()">Analyze Solar Potential</button>
        </div>

        <div id="status-messages"></div>

        <div id="loading" class="loading hidden">
            <div class="spinner"></div>
            <p>Analyzing solar potential...</p>
        </div>
    </div>

    <div id="results" class="container results">
        <h2>Solar Analysis Results</h2>

        <div class="result-grid">
            <div class="result-card">
                <h3>Location Information</h3>
                <div class="metric">
                    <span class="metric-label">Address:</span>
                    <span id="result-address">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Coordinates:</span>
                    <span id="result-coords">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Building Area:</span>
                    <span id="result-area">-</span>
                </div>
            </div>

            <div class="result-card">
                <h3>Solar Potential</h3>
                <div class="metric">
                    <span class="metric-label">Annual Solar Flux:</span>
                    <span id="result-flux">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Max Panel Count:</span>
                    <span id="result-panels">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Yearly Energy:</span>
                    <span id="result-energy">-</span>
                </div>
            </div>

            <div class="result-card">
                <h3>Financial Estimates</h3>
                <div class="metric">
                    <span class="metric-label">Installation Cost:</span>
                    <span id="result-cost">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Annual Savings:</span>
                    <span id="result-savings">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Payback Period:</span>
                    <span id="result-payback">-</span>
                </div>
            </div>

            <div class="result-card">
                <h3>Environmental Impact</h3>
                <div class="metric">
                    <span class="metric-label">COâ‚‚ Offset:</span>
                    <span id="result-co2">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Equivalent Trees:</span>
                    <span id="result-trees">-</span>
                </div>
            </div>

            <div class="result-card imagery-section">
                <h3>Roof Imagery & Analysis</h3>
                <div id="imagery-container">
                    <p>High-resolution roof imagery will appear here</p>
                </div>
            </div>
        </div>

        <button onclick="resetApp()">Analyze Another Address</button>
    </div>

    <script>
        const GOOGLE_API_KEY = 'AIzaSyCrLcxkBYE1_Duo2hGsyzo3ir-nJm7OnkE';

        let currentResults = null;

        async function analyzeSolar() {
            const address = document.getElementById('address-input').value.trim();
            const panelPower = parseFloat(document.getElementById('panel-power').value) || 620;
            const panelWidthMm = parseFloat(document.getElementById('panel-width').value) || 1134;
            const panelHeightMm = parseFloat(document.getElementById('panel-height').value) || 2278;

            // Convert millimeters to meters for calculations
            const panelWidth = panelWidthMm / 1000;
            const panelHeight = panelHeightMm / 1000;

            if (!address) {
                addStatusMessage('Please enter an address', 'error');
                return;
            }

            document.getElementById('loading').classList.remove('hidden');
            document.getElementById('results').style.display = 'none';
            clearStatusMessages();

            try {
                // Step 1: Geocode the address
                addStatusMessage('Geocoding address...', 'info');
                const geocodeResult = await geocodeAddress(address);

                if (!geocodeResult.success) {
                    throw new Error(geocodeResult.error);
                }

                addStatusMessage(`Found coordinates: ${geocodeResult.lat}, ${geocodeResult.lng}`, 'success');

                // Step 2: Get building insights
                addStatusMessage('Analyzing building solar potential...', 'info');
                const buildingInsights = await getBuildingInsights(geocodeResult.lat, geocodeResult.lng);

                // Step 3: Get imagery data
                addStatusMessage('Fetching roof imagery...', 'info');
                const imageryData = await getImageryData(geocodeResult.lat, geocodeResult.lng);

                // Step 4: Calculate results
                const results = calculateSolarMetrics(buildingInsights, imageryData, {
                    panelPower,
                    panelWidth,
                    panelHeight,
                    address: geocodeResult.formattedAddress,
                    lat: geocodeResult.lat,
                    lng: geocodeResult.lng
                });

                displayResults(results);
                addStatusMessage('Analysis complete!', 'success');

            } catch (error) {
                addStatusMessage(`Error: ${error.message}`, 'error');
            } finally {
                document.getElementById('loading').classList.add('hidden');
            }
        }

        async function geocodeAddress(address) {
            const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(address)}&key=${GOOGLE_API_KEY}`;

            try {
                const response = await fetch(url);
                const data = await response.json();

                if (data.status === 'OK' && data.results.length > 0) {
                    const result = data.results[0];
                    return {
                        success: true,
                        lat: result.geometry.location.lat,
                        lng: result.geometry.location.lng,
                        formattedAddress: result.formatted_address
                    };
                } else {
                    return {
                        success: false,
                        error: `Geocoding failed: ${data.status}`
                    };
                }
            } catch (error) {
                return {
                    success: false,
                    error: `Network error: ${error.message}`
                };
            }
        }

        async function getBuildingInsights(lat, lng) {
            // Try HIGH, MEDIUM, then BASE (experimental) quality levels
            const qualityLevels = ['HIGH', 'MEDIUM', 'BASE'];

            for (const quality of qualityLevels) {
                try {
                    let response, data;

                    if (quality === 'BASE') {
                        // For BASE quality, route through server to avoid CORS
                        const url = `/api/solar/building-insights`;
                        response = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ lat, lng })
                        });
                    } else {
                        // For HIGH and MEDIUM quality, use GET request
                        const url = `https://solar.googleapis.com/v1/buildingInsights:findClosest?location.latitude=${lat}&location.longitude=${lng}&requiredQuality=${quality}&key=${GOOGLE_API_KEY}`;
                        response = await fetch(url);
                    }

                    data = await response.json();

                    if (response.ok) {
                        const qualityInfo = quality === 'HIGH' ? '0.1m/pixel aerial' :
                                          quality === 'MEDIUM' ? '0.25m/pixel aerial' :
                                          '0.25m/pixel satellite (experimental)';
                        addStatusMessage(`Found solar data (${quality} quality - ${qualityInfo})`, 'success');
                        return data;
                    } else if (data.error?.message?.includes('not found') && quality !== 'BASE') {
                        addStatusMessage(`${quality} quality data not available, trying ${quality === 'HIGH' ? 'MEDIUM' : 'BASE (experimental)'}...`, 'info');
                        continue;
                    } else {
                        throw new Error(`Solar API error: ${data.error?.message || response.status}`);
                    }
                } catch (error) {
                    if (quality === 'BASE') {
                        throw new Error(`Failed to get building insights: ${error.message}`);
                    }
                    continue;
                }
            }
        }

        async function getImageryData(lat, lng) {
            // Try HIGH, MEDIUM, then BASE (experimental) quality levels
            const qualityLevels = ['HIGH', 'MEDIUM', 'BASE'];

            for (const quality of qualityLevels) {
                try {
                    let response, data;

                    if (quality === 'BASE') {
                        // For BASE quality, route through server to avoid CORS
                        const url = `/api/solar/imagery`;
                        response = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ lat, lng })
                        });
                    } else {
                        // For HIGH and MEDIUM quality, use GET request
                        const url = `https://solar.googleapis.com/v1/dataLayers:get?location.latitude=${lat}&location.longitude=${lng}&radiusMeters=100&requiredQuality=${quality}&key=${GOOGLE_API_KEY}`;
                        response = await fetch(url);
                    }

                    data = await response.json();

                    if (response.ok) {
                        addStatusMessage(`Retrieved imagery data (${quality} quality)`, 'success');
                        console.log('Imagery data received:', data);
                        // Handle server wrapper format for BASE quality
                        if (quality === 'BASE' && data.success && data.data) {
                            return data.data;
                        }
                        return data;
                    } else if (data.error?.message?.includes('not found') && quality !== 'BASE') {
                        continue;
                    } else {
                        console.warn('Failed to get imagery data:', data.error?.message);
                        if (quality === 'BASE') return null;
                        continue;
                    }
                } catch (error) {
                    console.warn('Failed to get imagery data:', error.message);
                    if (quality === 'BASE') return null;
                    continue;
                }
            }
            return null;
        }

        function calculateSolarMetrics(buildingInsights, imageryData, config) {
            const panelArea = config.panelWidth * config.panelHeight; // mÂ²

            // Extract data from Solar API response
            const roofSegmentSummaries = buildingInsights.solarPotential?.roofSegmentStats || [];
            const solarPanels = buildingInsights.solarPotential?.solarPanels || [];
            const financialAnalyses = buildingInsights.solarPotential?.financialAnalyses || [];

            // Calculate totals
            let totalRoofArea = 0;
            let maxPanelCount = 0;
            let yearlyEnergyDcKwh = 0;

            roofSegmentSummaries.forEach(segment => {
                if (segment.stats) {
                    totalRoofArea += segment.stats.areaM2 || 0;
                }
            });

            // Find the best configuration from solar panels
            if (solarPanels.length > 0) {
                const bestPanel = solarPanels.reduce((best, panel) => {
                    return (panel.yearlyEnergyDcKwh || 0) > (best.yearlyEnergyDcKwh || 0) ? panel : best;
                });

                maxPanelCount = bestPanel.panelsCount || 0;
                yearlyEnergyDcKwh = bestPanel.yearlyEnergyDcKwh || 0;
            }

            // Calculate financial metrics
            let installationCost = 0;
            let annualSavings = 0;
            let paybackYears = 0;

            if (financialAnalyses.length > 0) {
                const bestFinancial = financialAnalyses[0];
                installationCost = bestFinancial.upfrontCost?.value || maxPanelCount * 1000; // Fallback estimate
                annualSavings = bestFinancial.savings?.savingsYear1?.value || yearlyEnergyDcKwh * 0.12; // Fallback rate
                paybackYears = installationCost / (annualSavings || 1);
            }

            // Environmental calculations
            const co2OffsetKg = yearlyEnergyDcKwh * 0.4; // kg CO2 per kWh
            const equivalentTrees = Math.round(co2OffsetKg / 21); // Average tree absorbs ~21kg CO2/year

            return {
                address: config.address,
                lat: config.lat,
                lng: config.lng,
                buildingArea: totalRoofArea,
                maxPanelCount: maxPanelCount,
                yearlyEnergyKwh: yearlyEnergyDcKwh,
                installationCost: installationCost,
                annualSavings: annualSavings,
                paybackYears: paybackYears,
                co2OffsetKg: co2OffsetKg,
                equivalentTrees: equivalentTrees,
                imageryUrls: imageryData ? [
                    { name: 'RGB Imagery', imageUrl: imageryData.rgbUrl },
                    { name: 'Annual Solar Flux', imageUrl: imageryData.annualFluxUrl },
                    { name: 'Roof Mask', imageUrl: imageryData.maskUrl }
                ].filter(layer => {
                    console.log('Processing imagery layer:', layer.name, layer.imageUrl);
                    return layer.imageUrl;
                }) : [],
                rawBuildingInsights: buildingInsights,
                rawImageryData: imageryData
            };
        }

        function displayResults(results) {
            currentResults = results;

            // Location info
            document.getElementById('result-address').textContent = results.address;
            document.getElementById('result-coords').textContent = `${results.lat.toFixed(6)}, ${results.lng.toFixed(6)}`;
            document.getElementById('result-area').textContent = `${results.buildingArea.toFixed(1)} mÂ²`;

            // Solar potential
            document.getElementById('result-flux').textContent = 'Calculated from roof analysis';
            document.getElementById('result-panels').textContent = `${results.maxPanelCount} panels`;
            document.getElementById('result-energy').textContent = `${results.yearlyEnergyKwh.toFixed(0)} kWh/year`;

            // Financial
            document.getElementById('result-cost').textContent = `$${results.installationCost.toLocaleString()}`;
            document.getElementById('result-savings').textContent = `$${results.annualSavings.toFixed(0)}/year`;
            document.getElementById('result-payback').textContent = `${results.paybackYears.toFixed(1)} years`;

            // Environmental
            document.getElementById('result-co2').textContent = `${results.co2OffsetKg.toFixed(0)} kg/year`;
            document.getElementById('result-trees').textContent = `${results.equivalentTrees} trees`;

            // Display imagery
            displayImagery(results.imageryUrls);

            document.getElementById('results').style.display = 'block';
        }

        function displayImagery(imageryUrls) {
            const container = document.getElementById('imagery-container');

            if (!imageryUrls || imageryUrls.length === 0) {
                container.innerHTML = '<p>High-resolution imagery not available for this location</p>';
                return;
            }

            container.innerHTML = '<h4>Roof Imagery & Analysis</h4>';

            // Display each layer with labels
            imageryUrls.forEach((layer, index) => {
                if (layer.imageUrl) {
                    const layerDiv = document.createElement('div');
                    layerDiv.style.marginBottom = '20px';

                    const label = document.createElement('h5');
                    label.textContent = layer.name || `Layer ${index + 1}`;
                    label.style.marginBottom = '10px';
                    layerDiv.appendChild(label);

                    const img = document.createElement('img');
                    // Use conversion endpoint to convert GeoTIFF to PNG
                    const convertUrl = `/api/convert-image?url=${encodeURIComponent(layer.imageUrl)}`;
                    console.log(`Converting GeoTIFF to PNG: ${convertUrl}`);
                    img.src = convertUrl;
                    img.alt = layer.name || `Roof imagery layer ${index + 1}`;
                    img.style.maxWidth = '100%';
                    img.style.height = 'auto';
                    img.style.border = '1px solid #ddd';
                    img.style.borderRadius = '4px';
                    img.onload = () => {
                        console.log(`Successfully loaded ${layer.name || 'layer'} via proxy`);
                    };
                    img.onerror = () => {
                        console.warn('GeoTIFF format not displayable in browser:', layer);
                        img.style.display = 'none';
                        const downloadLink = document.createElement('a');
                        downloadLink.href = proxyUrl;
                        downloadLink.download = `${layer.name.replace(/\s+/g, '_')}.tiff`;
                        downloadLink.textContent = `ðŸ“¥ Download ${layer.name} (GeoTIFF)`;
                        downloadLink.style.display = 'inline-block';
                        downloadLink.style.padding = '8px 12px';
                        downloadLink.style.backgroundColor = '#007bff';
                        downloadLink.style.color = 'white';
                        downloadLink.style.textDecoration = 'none';
                        downloadLink.style.borderRadius = '4px';
                        downloadLink.style.margin = '5px';
                        layerDiv.appendChild(downloadLink);

                        const infoMsg = document.createElement('p');
                        infoMsg.textContent = `âœ… ${layer.name} data retrieved successfully (GeoTIFF format)`;
                        infoMsg.style.color = '#28a745';
                        infoMsg.style.fontSize = '14px';
                        layerDiv.appendChild(infoMsg);
                    };
                    layerDiv.appendChild(img);
                    container.appendChild(layerDiv);
                }
            });
        }

        function addStatusMessage(message, type) {
            const statusDiv = document.getElementById('status-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `status ${type}`;
            messageDiv.textContent = message;
            statusDiv.appendChild(messageDiv);
            statusDiv.scrollTop = statusDiv.scrollHeight;
        }

        function clearStatusMessages() {
            document.getElementById('status-messages').innerHTML = '';
        }

        function resetApp() {
            document.getElementById('results').style.display = 'none';
            document.getElementById('address-input').value = '';
            clearStatusMessages();
            currentResults = null;
        }

        // Google's exact renderRGB and renderPalette functions
        function renderRGB(rgb, mask) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = rgb.width;
            canvas.height = rgb.height;

            const imageData = ctx.createImageData(rgb.width, rgb.height);
            const data = imageData.data;

            for (let i = 0; i < rgb.width * rgb.height; i++) {
                const pixelIndex = i * 4;
                data[pixelIndex] = rgb.rasters[0][i];     // Red
                data[pixelIndex + 1] = rgb.rasters[1][i]; // Green
                data[pixelIndex + 2] = rgb.rasters[2][i]; // Blue
                data[pixelIndex + 3] = mask ? (mask.rasters[0][i] * 255) : 255; // Alpha
            }

            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        function createPalette(colors) {
            const palette = [];
            const steps = 256;

            for (let i = 0; i < steps; i++) {
                const ratio = i / (steps - 1);
                const colorIndex = ratio * (colors.length - 1);
                const lowerIndex = Math.floor(colorIndex);
                const upperIndex = Math.ceil(colorIndex);
                const t = colorIndex - lowerIndex;

                const lowerColor = hexToRgb(colors[lowerIndex]);
                const upperColor = hexToRgb(colors[upperIndex]);

                palette.push({
                    r: Math.round(lowerColor.r + t * (upperColor.r - lowerColor.r)),
                    g: Math.round(lowerColor.g + t * (upperColor.g - lowerColor.g)),
                    b: Math.round(lowerColor.b + t * (upperColor.b - lowerColor.b))
                });
            }

            return palette;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function normalize(value, max, min) {
            return Math.max(0, Math.min(1, (value - min) / (max - min)));
        }

        function renderPalette({ data, mask, colors = ['000000', 'ffffff'], min = 0, max = 1, index = 0 }) {
            const palette = createPalette(colors);
            const indices = data.rasters[index]
                .map(x => x === -9999 ? 0 : normalize(x, max, min))
                .map(x => Math.round(x * (palette.length - 1)));

            return renderRGB({
                width: data.width,
                height: data.height,
                rasters: [
                    indices.map(i => palette[i].r),
                    indices.map(i => palette[i].g),
                    indices.map(i => palette[i].b)
                ]
            }, mask);
        }

        // Process GeoTIFF layers using Google's approach
        async function processGeoTIFFLayers(imageryUrls, targetCanvas, targetCtx) {
            if (!imageryUrls || imageryUrls.length === 0) {
                const errorDiv = document.createElement('div');
                errorDiv.textContent = 'No imagery data available';
                targetCanvas.parentElement.appendChild(errorDiv);
                return;
            }

            const layers = {};

            // Process each layer
            for (const layer of imageryUrls) {
                try {
                    const layerType = getLayerType(layer.name);
                    console.log(`Processing ${layer.name} as ${layerType}`);

                    const response = await fetch(`/api/process-geotiff?url=${encodeURIComponent(layer.imageUrl)}&layer=${layerType}`);
                    const data = await response.json();

                    if (data.success) {
                        layers[layerType] = data;
                        console.log(`Successfully processed ${layer.name}:`, data.width, 'x', data.height);
                    } else {
                        console.warn(`Failed to process ${layer.name}:`, data.error);
                    }
                } catch (error) {
                    console.error(`Error processing ${layer.name}:`, error);
                }
            }

            // Render using Google's functions
            renderLayers(layers, targetCanvas, targetCtx);
        }

        function getLayerType(layerName) {
            if (layerName.includes('RGB')) return 'rgb';
            if (layerName.includes('Solar Flux') || layerName.includes('Annual')) return 'flux';
            if (layerName.includes('Mask')) return 'mask';
            return 'unknown';
        }

        function renderLayers(layers, targetCanvas, targetCtx) {
            const container = targetCanvas.parentElement;

            // Clear existing content
            while (container.children.length > 1) {
                container.removeChild(container.lastChild);
            }

            // Debug logging
            console.log('Available layers:', {
                rgb: !!layers.rgb,
                flux: !!layers.flux,
                mask: !!layers.mask
            });

            // Create composite image - prioritize showing single composite
            if (layers.rgb && layers.flux) {
                console.log('Creating composite with RGB + flux');

                // Use RGB as base layer
                const compositeCanvas = renderRGB({
                    width: layers.rgb.width,
                    height: layers.rgb.height,
                    rasters: [layers.rgb.data.red, layers.rgb.data.green, layers.rgb.data.blue]
                });

                // Create solar flux overlay with transparency
                const fluxCanvas = renderPalette({
                    data: {
                        width: layers.flux.width,
                        height: layers.flux.height,
                        rasters: [layers.flux.data]
                    },
                    colors: ['0000ff', '00ffff', 'ffff00', 'ff0000'],
                    min: layers.flux.stats.min,
                    max: layers.flux.stats.max,
                    index: 0
                });

                // Overlay solar flux on RGB with transparency
                const ctx = compositeCanvas.getContext('2d');
                ctx.globalAlpha = 0.6;
                ctx.drawImage(fluxCanvas, 0, 0);
                ctx.globalAlpha = 1.0;

                const compositeDiv = document.createElement('div');
                compositeDiv.innerHTML = `<h5>ðŸŒž Composite Solar Analysis (RGB + Solar Flux)</h5>`;
                compositeDiv.appendChild(compositeCanvas);
                container.appendChild(compositeDiv);

                // Show just this one - return early to skip individual layers
                targetCanvas.style.display = 'none';
                return;

            } else if (layers.rgb) {
                console.log('Creating RGB-only composite');

                const rgbCanvas = renderRGB({
                    width: layers.rgb.width,
                    height: layers.rgb.height,
                    rasters: [layers.rgb.data.red, layers.rgb.data.green, layers.rgb.data.blue]
                });

                const compositeDiv = document.createElement('div');
                compositeDiv.innerHTML = `<h5>ðŸŒž RGB Aerial Imagery</h5>`;
                compositeDiv.appendChild(rgbCanvas);
                container.appendChild(compositeDiv);

                targetCanvas.style.display = 'none';
                return;

            } else {
                console.log('Falling back to individual layers');
                // Fallback to individual layers if not all are available
                // Fallback to individual layers if not all are available
                if (layers.rgb) {
                    const rgbCanvas = renderRGB({
                        width: layers.rgb.width,
                        height: layers.rgb.height,
                        rasters: [layers.rgb.data.red, layers.rgb.data.green, layers.rgb.data.blue]
                    });

                    const rgbDiv = document.createElement('div');
                    rgbDiv.innerHTML = '<h5>RGB Aerial Imagery</h5>';
                    rgbDiv.appendChild(rgbCanvas);
                    container.appendChild(rgbDiv);
                }

                if (layers.flux) {
                    const fluxCanvas = renderPalette({
                        data: {
                            width: layers.flux.width,
                            height: layers.flux.height,
                            rasters: [layers.flux.data]
                        },
                        colors: ['0000ff', '00ffff', 'ffff00', 'ff0000'],
                        min: layers.flux.stats.min,
                        max: layers.flux.stats.max,
                        index: 0
                    });

                    const fluxDiv = document.createElement('div');
                    fluxDiv.innerHTML = `<h5>Solar Flux (${layers.flux.stats.min.toFixed(0)} - ${layers.flux.stats.max.toFixed(0)} kWh/mÂ²/year)</h5>`;
                    fluxDiv.appendChild(fluxCanvas);
                    container.appendChild(fluxDiv);
                }
            }

            // Hide target canvas since we're using custom rendering
            targetCanvas.style.display = 'none';
        }
    </script>

    <footer style="margin-top: 40px; padding: 20px; background-color: #f8f9fa; border-top: 1px solid #dee2e6;">
        <div style="max-width: 800px; margin: 0 auto;">
            <h5 style="color: #666; font-size: 14px; margin-bottom: 10px;">Changelog</h5>
            <div style="font-size: 12px; color: #888; line-height: 1.4;">
                <p><strong>v3.1</strong> (Latest) - Created composite solar visualization combining RGB and flux layers into single image</p>
                <p><strong>v3.0</strong> - Implemented Google's official renderRGB and renderPalette functions for proper GeoTIFF visualization</p>
                <p><strong>v2.1</strong> - Fixed imagery display for BASE quality data, Added proper expanded coverage support</p>
                <p><strong>v2.0</strong> - Fixed expanded coverage API calls to use GET requests instead of POST</p>
                <p><strong>v1.1</strong> - Added Malaysian address support with expanded coverage</p>
                <p><strong>v1.0</strong> - Initial release with standard coverage support</p>
            </div>
            <p style="font-size: 11px; color: #aaa; margin-top: 10px;">Last updated: 2025-09-29 (Build: v3.1-composite-viz)</p>
        </div>
    </footer>
</body>
</html>