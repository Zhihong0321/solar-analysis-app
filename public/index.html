<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar Analysis Tool v3.3</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .input-section {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr;
            gap: 15px;
            align-items: end;
            margin-bottom: 20px;
        }
        .input-group {
            display: flex;
            flex-direction: column;
        }
        label {
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        input[type="text"], input[type="number"], select {
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            background-color: white;
        }
        button {
            background-color: #007bff;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            height: fit-content;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
        }
        .status.success { background-color: #d4edda; color: #155724; }
        .status.error { background-color: #f8d7da; color: #721c24; }
        .status.info { background-color: #d1ecf1; color: #0c5460; }
        .results {
            display: none;
            margin-top: 20px;
        }
        .result-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .result-card {
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f8f9fa;
        }
        .result-card h3 {
            margin-top: 0;
            color: #007bff;
        }
        .metric {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
        }
        .metric-label {
            font-weight: bold;
        }
        .imagery-section {
            grid-column: 1 / -1;
            text-align: center;
        }
        .imagery-section img {
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin: 10px;
        }
        .loading {
            text-align: center;
            padding: 20px;
        }
        .spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .hidden { display: none; }
        @media (max-width: 768px) {
            .input-section {
                grid-template-columns: 1fr;
            }
            .result-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŒž Solar Analysis Tool <span style="font-size: 14px; color: #666;">[v3.3]</span></h1>

        <div class="input-section">
            <div class="input-group">
                <label for="address-input">Address</label>
                <input type="text" id="address-input" placeholder="Enter street address" value="jalan nada alam 4/2, taman nada alam, Negeri Sembilan" />
            </div>
            <div class="input-group">
                <label for="panel-power">Panel Power (W)</label>
                <input type="number" id="panel-power" value="400" min="100" max="1000" />
            </div>
            <div class="input-group">
                <label for="panel-width">Panel Width (mm)</label>
                <input type="number" id="panel-width" value="1045" min="500" max="3000" step="1" />
            </div>
        </div>

        <div class="input-section">
            <div class="input-group">
                <label for="panel-height">Panel Height (mm)</label>
                <input type="number" id="panel-height" value="1879" min="500" max="3000" step="1" />
            </div>
            <div class="input-group">
                <label for="quality-select">Data Quality</label>
                <select id="quality-select">
                    <option value="BASE" selected>BASE (Satellite)</option>
                    <option value="MEDIUM">MEDIUM (0.25m/pixel)</option>
                    <option value="HIGH">HIGH (0.1m/pixel)</option>
                </select>
            </div>
            <button id="analyze-btn" onclick="analyzeSolar()">Analyze Solar Potential</button>
        </div>

        <div id="status-messages"></div>

        <div id="loading" class="loading hidden">
            <div class="spinner"></div>
            <p>Analyzing solar potential...</p>
        </div>
    </div>

    <div id="results" class="container results">
        <h2>Solar Analysis Results</h2>

        <div class="result-grid">
            <div class="result-card">
                <h3>Location Information</h3>
                <div class="metric">
                    <span class="metric-label">Address:</span>
                    <span id="result-address">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Coordinates:</span>
                    <span id="result-coords">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Building Area:</span>
                    <span id="result-area">-</span>
                </div>
            </div>

            <div class="result-card">
                <h3>Solar Potential</h3>
                <div class="metric">
                    <span class="metric-label">Annual Solar Flux:</span>
                    <span id="result-flux">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Max Panel Count:</span>
                    <span id="result-panels">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Yearly Energy:</span>
                    <span id="result-energy">-</span>
                </div>
            </div>

            <div class="result-card">
                <h3>Financial Estimates</h3>
                <div class="metric">
                    <span class="metric-label">Installation Cost:</span>
                    <span id="result-cost">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Annual Savings:</span>
                    <span id="result-savings">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Payback Period:</span>
                    <span id="result-payback">-</span>
                </div>
            </div>

            <div class="result-card">
                <h3>Environmental Impact</h3>
                <div class="metric">
                    <span class="metric-label">COâ‚‚ Offset:</span>
                    <span id="result-co2">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Equivalent Trees:</span>
                    <span id="result-trees">-</span>
                </div>
            </div>

            <div class="result-card imagery-section">
                <h3>Roof Imagery & Analysis</h3>
                <div id="imagery-container">
                    <p>High-resolution roof imagery will appear here</p>
                </div>
            </div>
        </div>

        <button onclick="resetApp()">Analyze Another Address</button>
    </div>

    <script>
        const GOOGLE_API_KEY = 'AIzaSyCrLcxkBYE1_Duo2hGsyzo3ir-nJm7OnkE';

        let currentResults = null;

        async function analyzeSolar() {
            const address = document.getElementById('address-input').value.trim();
            const panelPower = parseFloat(document.getElementById('panel-power').value) || 400;
            const panelWidthMm = parseFloat(document.getElementById('panel-width').value) || 1045;
            const panelHeightMm = parseFloat(document.getElementById('panel-height').value) || 1879;

            // Convert millimeters to meters for calculations
            const panelWidth = panelWidthMm / 1000;
            const panelHeight = panelHeightMm / 1000;

            if (!address) {
                addStatusMessage('Please enter an address', 'error');
                return;
            }

            document.getElementById('loading').classList.remove('hidden');
            document.getElementById('results').style.display = 'none';
            clearStatusMessages();

            try {
                // Step 1: Geocode the address
                addStatusMessage('Geocoding address...', 'info');
                const geocodeResult = await geocodeAddress(address);

                if (!geocodeResult.success) {
                    throw new Error(geocodeResult.error);
                }

                addStatusMessage(`Found coordinates: ${geocodeResult.lat}, ${geocodeResult.lng}`, 'success');

                // Step 2: Get building insights
                addStatusMessage('Analyzing building solar potential...', 'info');
                const buildingInsights = await getBuildingInsights(geocodeResult.lat, geocodeResult.lng);

                // Step 3: Get imagery data
                addStatusMessage('Fetching roof imagery...', 'info');
                const imageryData = await getImageryData(geocodeResult.lat, geocodeResult.lng);

                // Step 4: Calculate results
                const results = calculateSolarMetrics(buildingInsights, imageryData, {
                    panelPower,
                    panelWidth,
                    panelHeight,
                    address: geocodeResult.formattedAddress,
                    lat: geocodeResult.lat,
                    lng: geocodeResult.lng
                });

                displayResults(results);
                addStatusMessage('Analysis complete!', 'success');

            } catch (error) {
                addStatusMessage(`Error: ${error.message}`, 'error');
            } finally {
                document.getElementById('loading').classList.add('hidden');
            }
        }

        async function geocodeAddress(address) {
            const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(address)}&key=${GOOGLE_API_KEY}`;

            try {
                const response = await fetch(url);
                const data = await response.json();

                if (data.status === 'OK' && data.results.length > 0) {
                    const result = data.results[0];
                    return {
                        success: true,
                        lat: result.geometry.location.lat,
                        lng: result.geometry.location.lng,
                        formattedAddress: result.formatted_address
                    };
                } else {
                    return {
                        success: false,
                        error: `Geocoding failed: ${data.status}`
                    };
                }
            } catch (error) {
                return {
                    success: false,
                    error: `Network error: ${error.message}`
                };
            }
        }

        async function getBuildingInsights(lat, lng) {
            // Use selected quality level, but for Malaysia always try BASE first
            const selectedQuality = document.getElementById('quality-select').value;
            const qualityLevels = selectedQuality === 'BASE' ? ['BASE'] : [selectedQuality, 'BASE'];

            for (const quality of qualityLevels) {
                try {
                    let response, data;

                    if (quality === 'BASE') {
                        // For BASE quality, route through server to avoid CORS
                        const url = `/api/solar/building-insights`;
                        response = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ lat, lng })
                        });
                    } else {
                        // For HIGH and MEDIUM quality, use GET request
                        const url = `https://solar.googleapis.com/v1/buildingInsights:findClosest?location.latitude=${lat}&location.longitude=${lng}&requiredQuality=${quality}&key=${GOOGLE_API_KEY}`;
                        response = await fetch(url);
                    }

                    data = await response.json();

                    if (response.ok) {
                        const qualityInfo = quality === 'HIGH' ? '0.1m/pixel aerial' :
                                          quality === 'MEDIUM' ? '0.25m/pixel aerial' :
                                          '0.25m/pixel satellite (experimental)';
                        addStatusMessage(`Found solar data (${quality} quality - ${qualityInfo})`, 'success');
                        return data;
                    } else if (data.error?.message?.includes('not found') && quality !== 'BASE') {
                        addStatusMessage(`${quality} quality data not available, trying ${quality === 'HIGH' ? 'MEDIUM' : 'BASE (experimental)'}...`, 'info');
                        continue;
                    } else {
                        throw new Error(`Solar API error: ${data.error?.message || response.status}`);
                    }
                } catch (error) {
                    if (quality === 'BASE') {
                        throw new Error(`Failed to get building insights: ${error.message}`);
                    }
                    continue;
                }
            }
        }

        async function getImageryData(lat, lng) {
            // Use selected quality level, but for Malaysia always try BASE first
            const selectedQuality = document.getElementById('quality-select').value;
            const qualityLevels = selectedQuality === 'BASE' ? ['BASE'] : [selectedQuality, 'BASE'];

            for (const quality of qualityLevels) {
                try {
                    let response, data;

                    if (quality === 'BASE') {
                        // For BASE quality, route through server to avoid CORS
                        const url = `/api/solar/imagery`;
                        response = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ lat, lng })
                        });
                    } else {
                        // For HIGH and MEDIUM quality, use GET request
                        const url = `https://solar.googleapis.com/v1/dataLayers:get?location.latitude=${lat}&location.longitude=${lng}&radiusMeters=100&requiredQuality=${quality}&key=${GOOGLE_API_KEY}`;
                        response = await fetch(url);
                    }

                    data = await response.json();

                    if (response.ok) {
                        addStatusMessage(`Retrieved imagery data (${quality} quality)`, 'success');
                        console.log('Imagery data received:', data);
                        // Handle server wrapper format for BASE quality
                        if (quality === 'BASE' && data.success && data.data) {
                            return data.data;
                        }
                        return data;
                    } else if (data.error?.message?.includes('not found') && quality !== 'BASE') {
                        continue;
                    } else {
                        console.warn('Failed to get imagery data:', data.error?.message);
                        if (quality === 'BASE') return null;
                        continue;
                    }
                } catch (error) {
                    console.warn('Failed to get imagery data:', error.message);
                    if (quality === 'BASE') return null;
                    continue;
                }
            }
            return null;
        }

        function calculateSolarMetrics(buildingInsights, imageryData, config) {
            const panelArea = config.panelWidth * config.panelHeight; // mÂ²

            // Debug the buildingInsights structure
            console.log('Building insights validation:', {
                hasBuildingInsights: !!buildingInsights,
                hasSolarPotential: !!buildingInsights?.solarPotential,
                solarPotentialKeys: buildingInsights?.solarPotential ? Object.keys(buildingInsights.solarPotential) : [],
                buildingInsightsKeys: buildingInsights ? Object.keys(buildingInsights) : []
            });

            // Only validate if absolutely no data
            if (!buildingInsights || !buildingInsights.solarPotential || !buildingInsights.solarPotential.solarPanelConfigs) {
                console.error('Solar potential data not available for this location');
                return {
                    address: config.address,
                    lat: config.lat,
                    lng: config.lng,
                    buildingArea: 0,
                    maxPanelCount: 0,
                    yearlyEnergyKwh: 0,
                    yearlyEnergyDcKwh: 0,
                    lifetimeProductionAcKwh: 0,
                    installationCost: 0,
                    annualSavings: 0,
                    paybackYears: 0,
                    co2OffsetKg: 0,
                    equivalentTrees: 0,
                    error: 'Solar potential data not available for this location',
                    imageryUrls: imageryData ? [
                        { name: 'RGB Imagery', imageUrl: imageryData.rgbUrl }
                    ].filter(layer => layer.imageUrl) : []
                };
            }

            // Extract data from Solar API response
            const roofSegmentSummaries = buildingInsights.solarPotential?.roofSegmentStats || [];
            const solarPanelConfigs = buildingInsights.solarPotential?.solarPanelConfigs || [];
            const financialAnalyses = buildingInsights.solarPotential?.financialAnalyses || [];

            // Calculate totals
            let totalRoofArea = 0;
            let maxPanelCount = 0;
            let yearlyEnergyDcKwh = 0;

            roofSegmentSummaries.forEach(segment => {
                if (segment.stats) {
                    totalRoofArea += segment.stats.areaM2 || 0;
                }
            });

            // Find the best configuration from solar panel configs
            if (solarPanelConfigs.length > 0) {
                const bestConfig = solarPanelConfigs.reduce((best, config) => {
                    return (config.yearlyEnergyDcKwh || 0) > (best.yearlyEnergyDcKwh || 0) ? config : best;
                });

                // Extract API values directly - they already account for roof layout
                const apiYearlyEnergyDcKwh = bestConfig.yearlyEnergyDcKwh || 0;
                const apiPanelCount = bestConfig.panelsCount || 0;

                // Get panel capacity from API response
                const apiPanelWatts = buildingInsights.solarPotential.panelCapacityWatts || 400;

                // User's custom panel power rating
                const userPanelWatts = config.panelPower;

                // Apply Google's formula: adjust energy production for custom panel power rating
                // "multiply the value returned by the API in the yearlyEnergyDcKwh field by the ratio of your power rating"
                const powerRatio = userPanelWatts / apiPanelWatts;
                yearlyEnergyDcKwh = apiYearlyEnergyDcKwh * powerRatio;

                // For panel count, if user panels are different size, calculate how many fit
                const userPanelArea = config.panelWidth * config.panelHeight;
                const apiPanelArea = (buildingInsights.solarPotential.panelHeightMeters || 1.879) * (buildingInsights.solarPotential.panelWidthMeters || 1.045);
                maxPanelCount = Math.floor(apiPanelCount * (apiPanelArea / userPanelArea));

                console.log('Solar calculation (FIXED - per Google docs):', {
                    availableConfigs: solarPanelConfigs.length,
                    bestConfig: bestConfig,
                    apiEnergy: apiYearlyEnergyDcKwh,
                    apiPanelWatts: apiPanelWatts,
                    userPanelWatts: userPanelWatts,
                    powerRatio: powerRatio,
                    adjustedEnergy: yearlyEnergyDcKwh,
                    apiPanelCount: apiPanelCount,
                    adjustedPanelCount: maxPanelCount
                });
            } else {
                console.error('No solarPanelConfigs found in API response!');
            }

            // Apply Google's DC-to-AC conversion and lifetime calculations
            const dcToAcDerate = 0.85; // 85% efficiency (Google's default)
            const initialAcKwhPerYear = yearlyEnergyDcKwh * dcToAcDerate;

            // Calculate lifetime production (Google's formula for non-US)
            const efficiencyDepreciationFactor = 0.995; // 0.5% annual decrease
            const installationLifeSpan = 20; // years

            const lifetimeProductionAcKwh = (
                dcToAcDerate *
                yearlyEnergyDcKwh *
                (1 - Math.pow(efficiencyDepreciationFactor, installationLifeSpan)) /
                (1 - efficiencyDepreciationFactor)
            );

            // Calculate financial metrics
            let installationCost = 0;
            let annualSavings = 0;
            let paybackYears = 0;

            if (financialAnalyses.length > 0) {
                const bestFinancial = financialAnalyses[0];
                installationCost = bestFinancial.upfrontCost?.value || maxPanelCount * 1000; // Fallback estimate
                annualSavings = bestFinancial.savings?.savingsYear1?.value || initialAcKwhPerYear * 0.12; // Use AC energy
                paybackYears = installationCost / (annualSavings || 1);
            } else {
                // Fallback calculation for non-US regions
                const estimatedCostPerPanel = 1000; // USD estimate
                installationCost = maxPanelCount * estimatedCostPerPanel;
                const electricityRate = 0.12; // USD per kWh estimate
                annualSavings = initialAcKwhPerYear * electricityRate;
                paybackYears = installationCost / (annualSavings || 1);
            }

            // Environmental calculations
            const co2OffsetKg = yearlyEnergyDcKwh * 0.4; // kg CO2 per kWh
            const equivalentTrees = Math.round(co2OffsetKg / 21); // Average tree absorbs ~21kg CO2/year

            console.log('Final calculations (Google non-US method):', {
                yearlyEnergyDcKwh: yearlyEnergyDcKwh,
                initialAcKwhPerYear: initialAcKwhPerYear,
                lifetimeProductionAcKwh: lifetimeProductionAcKwh,
                installationCost: installationCost,
                annualSavings: annualSavings,
                paybackYears: paybackYears
            });

            return {
                address: config.address,
                lat: config.lat,
                lng: config.lng,
                buildingArea: totalRoofArea,
                maxPanelCount: maxPanelCount,
                yearlyEnergyKwh: initialAcKwhPerYear, // Use AC energy for display
                yearlyEnergyDcKwh: yearlyEnergyDcKwh, // Keep DC for reference
                lifetimeProductionAcKwh: lifetimeProductionAcKwh,
                installationCost: installationCost,
                annualSavings: annualSavings,
                paybackYears: paybackYears,
                co2OffsetKg: co2OffsetKg,
                equivalentTrees: equivalentTrees,
                imageryUrls: imageryData ? [
                    { name: 'RGB Imagery', imageUrl: imageryData.rgbUrl },
                    { name: 'Annual Solar Flux', imageUrl: imageryData.annualFluxUrl },
                    { name: 'Roof Mask', imageUrl: imageryData.maskUrl }
                ].filter(layer => {
                    console.log('Processing imagery layer:', layer.name, layer.imageUrl);
                    return layer.imageUrl;
                }) : [],
                rawBuildingInsights: buildingInsights,
                rawImageryData: imageryData
            };
        }

        function displayResults(results) {
            currentResults = results;

            // Check if there's an error in the results
            if (results.error) {
                // Show error message
                document.getElementById('result-address').textContent = results.address;
                document.getElementById('result-coords').textContent = `${results.lat.toFixed(6)}, ${results.lng.toFixed(6)}`;
                document.getElementById('result-area').textContent = 'N/A';

                // Show error for solar potential
                document.getElementById('result-flux').textContent = results.error;
                document.getElementById('result-panels').textContent = 'N/A';
                document.getElementById('result-energy').textContent = 'N/A';

                // Show error for financial
                document.getElementById('result-cost').textContent = 'N/A';
                document.getElementById('result-savings').textContent = 'N/A';
                document.getElementById('result-payback').textContent = 'N/A';

                // Show error for environmental
                document.getElementById('result-co2').textContent = 'N/A';
                document.getElementById('result-trees').textContent = 'N/A';

                // Still try to display imagery if available
                displayImagery(results.imageryUrls);

                document.getElementById('results').style.display = 'block';
                return;
            }

            // Normal display for successful results
            // Location info
            document.getElementById('result-address').textContent = results.address;
            document.getElementById('result-coords').textContent = `${results.lat.toFixed(6)}, ${results.lng.toFixed(6)}`;
            document.getElementById('result-area').textContent = `${results.buildingArea.toFixed(1)} mÂ²`;

            // Solar potential
            document.getElementById('result-flux').textContent = 'Calculated from roof analysis';
            document.getElementById('result-panels').textContent = `${results.maxPanelCount} panels`;
            document.getElementById('result-energy').textContent = `${results.yearlyEnergyKwh.toFixed(0)} kWh/year`;

            // Financial
            document.getElementById('result-cost').textContent = `$${results.installationCost.toLocaleString()}`;
            document.getElementById('result-savings').textContent = `$${results.annualSavings.toFixed(0)}/year`;
            document.getElementById('result-payback').textContent = `${results.paybackYears.toFixed(1)} years`;

            // Environmental
            document.getElementById('result-co2').textContent = `${results.co2OffsetKg.toFixed(0)} kg/year`;
            document.getElementById('result-trees').textContent = `${results.equivalentTrees} trees`;

            // Display imagery
            displayImagery(results.imageryUrls);

            document.getElementById('results').style.display = 'block';
        }

        function displayImagery(imageryUrls) {
            const container = document.getElementById('imagery-container');

            if (!imageryUrls || imageryUrls.length === 0) {
                container.innerHTML = '<p>High-resolution imagery not available for this location</p>';
                return;
            }

            container.innerHTML = '<h4>Roof Imagery</h4>';

            // Find and display only RGB roof imagery
            const rgbLayer = imageryUrls.find(layer =>
                layer.name && layer.name.includes('RGB') && layer.imageUrl
            );

            if (rgbLayer) {
                const imageDiv = document.createElement('div');
                imageDiv.style.marginBottom = '20px';

                const title = document.createElement('h5');
                title.textContent = 'Roof Image';
                title.style.margin = '0 0 10px 0';
                imageDiv.appendChild(title);

                const img = document.createElement('img');
                const imageUrl = `/api/convert-image?url=${encodeURIComponent(rgbLayer.imageUrl)}`;
                console.log('Loading roof image:', imageUrl);

                img.src = imageUrl;
                img.alt = 'Roof imagery';
                img.style.maxWidth = '100%';
                img.style.height = 'auto';
                img.style.border = '1px solid #ddd';
                img.style.borderRadius = '4px';

                img.onload = () => {
                    console.log('Roof image loaded successfully');
                };

                img.onerror = () => {
                    console.error('Failed to load roof image');
                    img.style.display = 'none';
                    const errorMsg = document.createElement('p');
                    errorMsg.textContent = 'Failed to load roof image';
                    errorMsg.style.color = '#dc3545';
                    imageDiv.appendChild(errorMsg);
                };

                imageDiv.appendChild(img);
                container.appendChild(imageDiv);
            } else {
                container.innerHTML += '<p>No roof imagery available</p>';
            }
        }

        function addStatusMessage(message, type) {
            const statusDiv = document.getElementById('status-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `status ${type}`;
            messageDiv.textContent = message;
            statusDiv.appendChild(messageDiv);
            statusDiv.scrollTop = statusDiv.scrollHeight;
        }

        function clearStatusMessages() {
            document.getElementById('status-messages').innerHTML = '';
        }

        function resetApp() {
            document.getElementById('results').style.display = 'none';
            document.getElementById('address-input').value = '';
            clearStatusMessages();
            currentResults = null;
        }

        // Google's EXACT implementation from documentation
        function renderRGB(rgb, mask) {
            const canvas = document.createElement('canvas');
            canvas.width = mask ? mask.width : rgb.width;
            canvas.height = mask ? mask.height : rgb.height;

            const dw = rgb.width / canvas.width;
            const dh = rgb.height / canvas.height;

            const ctx = canvas.getContext('2d');
            const img = ctx.getImageData(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const rgbIdx = Math.floor(y * dh) * rgb.width + Math.floor(x * dw);
                    const maskIdx = y * canvas.width + x;
                    const imgIdx = y * canvas.width * 4 + x * 4;

                    img.data[imgIdx + 0] = rgb.rasters[0][rgbIdx]; // Red
                    img.data[imgIdx + 1] = rgb.rasters[1][rgbIdx]; // Green
                    img.data[imgIdx + 2] = rgb.rasters[2][rgbIdx]; // Blue
                    img.data[imgIdx + 3] = mask && mask.rasters && mask.rasters[0]
                        ? mask.rasters[0][maskIdx] * 255
                        : 255;
                }
            }

            ctx.putImageData(img, 0, 0);
            return canvas;
        }

        function colorToRGB(color) {
            const hex = color.startsWith('#') ? color.slice(1) : color;
            return {
                r: parseInt(hex.substring(0, 2), 16),
                g: parseInt(hex.substring(2, 4), 16),
                b: parseInt(hex.substring(4, 6), 16),
            };
        }

        function normalize(x, max = 1, min = 0) {
            const y = (x - min) / (max - min);
            return clamp(y, 0, 1);
        }

        function lerp(x, y, t) {
            return x + t * (y - x);
        }

        function clamp(x, min, max) {
            return Math.min(Math.max(x, min), max);
        }

        function createPalette(hexColors) {
            const rgb = hexColors.map(colorToRGB);
            const size = 256;
            const step = (rgb.length - 1) / (size - 1);
            return Array(size)
                .fill(0)
                .map((_, i) => {
                    const index = i * step;
                    const lower = Math.floor(index);
                    const upper = Math.ceil(index);
                    return {
                        r: lerp(rgb[lower].r, rgb[upper].r, index - lower),
                        g: lerp(rgb[lower].g, rgb[upper].g, index - lower),
                        b: lerp(rgb[lower].b, rgb[upper].b, index - lower),
                    };
                });
        }

        function renderPalette({ data, mask, colors, min, max, index }) {
            const palette = createPalette(colors ?? ['000000', 'ffffff']);
            const indices = data.rasters[index ?? 0]
                .map((x) => normalize(x, max ?? 1, min ?? 0))
                .map((x) => Math.round(x * (palette.length - 1)));
            return renderRGB(
                {
                    ...data,
                    rasters: [
                        indices.map((i) => palette[i].r),
                        indices.map((i) => palette[i].g),
                        indices.map((i) => palette[i].b),
                    ],
                },
                mask,
            );
        }

        // Process GeoTIFF layers using Google's approach
        async function processGeoTIFFLayers(imageryUrls, targetCanvas, targetCtx) {
            if (!imageryUrls || imageryUrls.length === 0) {
                const errorDiv = document.createElement('div');
                errorDiv.textContent = 'No imagery data available';
                targetCanvas.parentElement.appendChild(errorDiv);
                return;
            }

            const layers = {};

            // Process each layer
            for (const layer of imageryUrls) {
                try {
                    const layerType = getLayerType(layer.name);
                    console.log(`Processing ${layer.name} as ${layerType}`);

                    const response = await fetch(`/api/process-geotiff?url=${encodeURIComponent(layer.imageUrl)}&layer=${layerType}`);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();

                    if (data.success) {
                        layers[layerType] = data;
                        console.log(`Successfully processed ${layer.name}:`, data.width, 'x', data.height);
                    } else {
                        console.warn(`Failed to process ${layer.name}:`, data.error);
                    }
                } catch (error) {
                    console.error(`Error processing ${layer.name}:`, error);
                }
            }

            // Render using Google's functions
            renderLayers(layers, targetCanvas, targetCtx);
        }

        function getLayerType(layerName) {
            if (layerName.includes('RGB')) return 'rgb';
            if (layerName.includes('Solar Flux') || layerName.includes('Annual')) return 'flux';
            if (layerName.includes('Mask')) return 'mask';
            return 'unknown';
        }

        function renderLayers(layers, targetCanvas, targetCtx) {
            const container = targetCanvas.parentElement;

            // Clear existing content except the title
            while (container.children.length > 1) {
                container.removeChild(container.lastChild);
            }

            console.log('Rendering layers using Google approach:', Object.keys(layers));

            // Render RGB layer if available
            if (layers.rgb) {
                const rgbData = {
                    width: layers.rgb.width,
                    height: layers.rgb.height,
                    rasters: [layers.rgb.data.red, layers.rgb.data.green, layers.rgb.data.blue]
                };

                const rgbCanvas = renderRGB(rgbData, undefined);

                const rgbDiv = document.createElement('div');
                rgbDiv.style.marginBottom = '20px';
                const rgbTitle = document.createElement('h5');
                rgbTitle.textContent = 'RGB Aerial Imagery';
                rgbTitle.style.margin = '0 0 10px 0';
                rgbDiv.appendChild(rgbTitle);
                rgbDiv.appendChild(rgbCanvas);
                container.appendChild(rgbDiv);
            }

            // Render Solar Flux layer if available
            if (layers.flux) {
                const fluxData = {
                    width: layers.flux.width,
                    height: layers.flux.height,
                    rasters: [layers.flux.data]
                };

                const fluxCanvas = renderPalette({
                    data: fluxData,
                    colors: ['0000ff', '00ffff', 'ffff00', 'ff0000'],
                    min: layers.flux.stats.min,
                    max: layers.flux.stats.max,
                    index: 0
                });

                const fluxDiv = document.createElement('div');
                fluxDiv.style.marginBottom = '20px';
                const fluxTitle = document.createElement('h5');
                fluxTitle.textContent = `Annual Solar Flux (${layers.flux.stats.min.toFixed(0)} - ${layers.flux.stats.max.toFixed(0)} kWh/mÂ²/year)`;
                fluxTitle.style.margin = '0 0 10px 0';
                fluxDiv.appendChild(fluxTitle);
                fluxDiv.appendChild(fluxCanvas);
                container.appendChild(fluxDiv);
            }

            // Render Roof Mask if available
            if (layers.mask) {
                const maskData = {
                    width: layers.mask.width,
                    height: layers.mask.height,
                    rasters: [layers.mask.data]
                };

                const maskCanvas = renderPalette({
                    data: maskData,
                    colors: ['000000', 'ffffff'],
                    min: 0,
                    max: 1,
                    index: 0
                });

                const maskDiv = document.createElement('div');
                maskDiv.style.marginBottom = '20px';
                const maskTitle = document.createElement('h5');
                maskTitle.textContent = 'Roof Mask';
                maskTitle.style.margin = '0 0 10px 0';
                maskDiv.appendChild(maskTitle);
                maskDiv.appendChild(maskCanvas);
                container.appendChild(maskDiv);
            }

            // Hide the original target canvas
            targetCanvas.style.display = 'none';
        }
    </script>

    <footer style="margin-top: 40px; padding: 20px; background-color: #f8f9fa; border-top: 1px solid #dee2e6;">
        <div style="max-width: 800px; margin: 0 auto;">
            <h5 style="color: #666; font-size: 14px; margin-bottom: 10px;">Changelog</h5>
            <div style="font-size: 12px; color: #888; line-height: 1.4;">
                <p><strong>v3.3</strong> (Latest) - Simplified to show only working roof imagery, added quality dropdown, set default Malaysian address</p>
                <p><strong>v3.2</strong> - Implemented Google's EXACT Solar API specification with proper renderRGB and renderPalette functions</p>
                <p><strong>v3.1</strong> - Created composite solar visualization combining RGB and flux layers into single image</p>
                <p><strong>v3.0</strong> - Implemented Google's official renderRGB and renderPalette functions for proper GeoTIFF visualization</p>
                <p><strong>v2.1</strong> - Fixed imagery display for BASE quality data, Added proper expanded coverage support</p>
                <p><strong>v2.0</strong> - Fixed expanded coverage API calls to use GET requests instead of POST</p>
                <p><strong>v1.1</strong> - Added Malaysian address support with expanded coverage</p>
                <p><strong>v1.0</strong> - Initial release with standard coverage support</p>
            </div>
            <p style="font-size: 11px; color: #aaa; margin-top: 10px;">Last updated: 2025-09-29 (Build: v3.3-simple-roof-only)</p>
        </div>
    </footer>
</body>
</html>