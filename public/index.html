<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar Analysis Tool</title>
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCrLcxkBYE1_Duo2hGsyzo3ir-nJm7OnkE&libraries=places"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .input-section {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr;
            gap: 15px;
            align-items: end;
            margin-bottom: 20px;
        }
        .input-group {
            display: flex;
            flex-direction: column;
        }
        label {
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        input[type="text"], input[type="number"] {
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        button {
            background-color: #007bff;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            height: fit-content;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
        }
        .status.success { background-color: #d4edda; color: #155724; }
        .status.error { background-color: #f8d7da; color: #721c24; }
        .status.info { background-color: #d1ecf1; color: #0c5460; }
        .results {
            display: none;
            margin-top: 20px;
        }
        .result-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .result-card {
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f8f9fa;
        }
        .result-card h3 {
            margin-top: 0;
            color: #007bff;
        }
        .metric {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
        }
        .metric-label {
            font-weight: bold;
        }
        .imagery-section {
            grid-column: 1 / -1;
            text-align: center;
        }
        .imagery-section img {
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin: 10px;
        }
        .loading {
            text-align: center;
            padding: 20px;
        }
        .spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .hidden { display: none; }
        #map {
            width: 100%;
            height: 400px;
            border: 2px solid #ddd;
            border-radius: 8px;
            margin-top: 20px;
            display: none;
        }
        #map.visible {
            display: block;
        }
        .map-instructions {
            margin-top: 10px;
            padding: 10px;
            background-color: #e7f3ff;
            border-left: 4px solid #007bff;
            border-radius: 4px;
            font-size: 14px;
            display: none;
        }
        .map-instructions.visible {
            display: block;
        }
        @media (max-width: 768px) {
            .input-section {
                grid-template-columns: 1fr;
            }
            .result-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŒž Solar Analysis Tool</h1>

        <div class="input-section">
            <div class="input-group">
                <label for="address-input">Address</label>
                <input type="text" id="address-input" placeholder="Enter street address" />
            </div>
            <div class="input-group">
                <label for="panel-power">Panel Power (W)</label>
                <input type="number" id="panel-power" value="620" min="100" max="1000" />
            </div>
            <div class="input-group">
                <button id="search-btn" onclick="searchAddress()" style="width: 100%;">Search Address</button>
            </div>
        </div>

        <div id="map"></div>
        <div id="map-instructions" class="map-instructions">
            Click on the map to pinpoint the exact location for solar analysis
        </div>

        <div class="input-section" style="margin-top: 20px;">
            <div class="input-group">
                <label for="panel-width">Panel Width (mm)</label>
                <input type="number" id="panel-width" value="1134" min="500" max="3000" step="1" />
            </div>
            <div class="input-group">
                <label for="panel-height">Panel Height (mm)</label>
                <input type="number" id="panel-height" value="2278" min="500" max="3000" step="1" />
            </div>
            <button id="analyze-btn" onclick="analyzeSolar()" disabled>Analyze Solar Potential</button>
        </div>

        <div id="status-messages"></div>

        <div id="loading" class="loading hidden">
            <div class="spinner"></div>
            <p>Analyzing solar potential...</p>
        </div>
    </div>

    <div id="results" class="container results">
        <h2>Solar Analysis Results</h2>

        <div class="result-grid">
            <div class="result-card">
                <h3>Location Information</h3>
                <div class="metric">
                    <span class="metric-label">Address:</span>
                    <span id="result-address">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Coordinates:</span>
                    <span id="result-coords">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Building Area:</span>
                    <span id="result-area">-</span>
                </div>
            </div>

            <div class="result-card">
                <h3>Solar Potential</h3>
                <div class="metric">
                    <span class="metric-label">Annual Solar Flux:</span>
                    <span id="result-flux">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Max Panel Count:</span>
                    <span id="result-panels">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Yearly Energy:</span>
                    <span id="result-energy">-</span>
                </div>
            </div>

            <div class="result-card">
                <h3>Financial Estimates</h3>
                <div class="metric">
                    <span class="metric-label">Installation Cost:</span>
                    <span id="result-cost">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Annual Savings:</span>
                    <span id="result-savings">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Payback Period:</span>
                    <span id="result-payback">-</span>
                </div>
            </div>

            <div class="result-card">
                <h3>Environmental Impact</h3>
                <div class="metric">
                    <span class="metric-label">COâ‚‚ Offset:</span>
                    <span id="result-co2">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Equivalent Trees:</span>
                    <span id="result-trees">-</span>
                </div>
            </div>

            <div class="result-card imagery-section">
                <h3>Roof Imagery & Analysis</h3>
                <div id="imagery-container">
                    <p>High-resolution roof imagery will appear here</p>
                </div>
            </div>
        </div>

        <button onclick="resetApp()">Analyze Another Address</button>
    </div>

    <script>
        const GOOGLE_API_KEY = 'AIzaSyCrLcxkBYE1_Duo2hGsyzo3ir-nJm7OnkE';

        let currentResults = null;
        let map = null;
        let marker = null;
        let selectedLocation = null;
        let geocoder = null;

        function initMap() {
            // Initialize map centered on a default location
            map = new google.maps.Map(document.getElementById('map'), {
                center: { lat: 3.139, lng: 101.6869 }, // Kuala Lumpur default
                zoom: 15,
                mapTypeId: 'satellite'
            });

            geocoder = new google.maps.Geocoder();

            // Add click listener to map for pinpointing
            map.addListener('click', function(event) {
                placeMarker(event.latLng);
            });
        }

        function placeMarker(location) {
            // Remove existing marker if any
            if (marker) {
                marker.setMap(null);
            }

            // Create new marker
            marker = new google.maps.Marker({
                position: location,
                map: map,
                draggable: true,
                title: 'Selected Location'
            });

            // Update selected location
            selectedLocation = {
                lat: location.lat(),
                lng: location.lng()
            };

            // Enable analyze button
            document.getElementById('analyze-btn').disabled = false;

            // Add drag listener to marker
            marker.addListener('dragend', function(event) {
                selectedLocation = {
                    lat: event.latLng.lat(),
                    lng: event.latLng.lng()
                };
            });

            addStatusMessage(`Location selected: ${selectedLocation.lat.toFixed(6)}, ${selectedLocation.lng.toFixed(6)}`, 'success');
        }

        async function searchAddress() {
            const address = document.getElementById('address-input').value.trim();

            if (!address) {
                addStatusMessage('Please enter an address', 'error');
                return;
            }

            clearStatusMessages();
            addStatusMessage('Searching for address...', 'info');

            try {
                const geocodeResult = await geocodeAddress(address);

                if (!geocodeResult.success) {
                    throw new Error(geocodeResult.error);
                }

                // Show map
                const mapElement = document.getElementById('map');
                const instructionsElement = document.getElementById('map-instructions');
                mapElement.classList.add('visible');
                instructionsElement.classList.add('visible');

                // Initialize map if not already initialized
                if (!map) {
                    initMap();
                }

                // Center map on geocoded location
                const location = new google.maps.LatLng(geocodeResult.lat, geocodeResult.lng);
                map.setCenter(location);
                map.setZoom(20);

                // Place marker at geocoded location
                placeMarker(location);

                addStatusMessage(`Found: ${geocodeResult.formattedAddress}`, 'success');
                addStatusMessage('Click on the map to adjust the pinpoint location', 'info');

            } catch (error) {
                addStatusMessage(`Error: ${error.message}`, 'error');
            }
        }

        async function analyzeSolar() {
            if (!selectedLocation) {
                addStatusMessage('Please search for an address and pinpoint a location on the map first', 'error');
                return;
            }

            const panelPower = parseFloat(document.getElementById('panel-power').value) || 620;
            const panelWidthMm = parseFloat(document.getElementById('panel-width').value) || 1134;
            const panelHeightMm = parseFloat(document.getElementById('panel-height').value) || 2278;

            // Convert millimeters to meters for calculations
            const panelWidth = panelWidthMm / 1000;
            const panelHeight = panelHeightMm / 1000;

            document.getElementById('loading').classList.remove('hidden');
            document.getElementById('results').style.display = 'none';
            clearStatusMessages();

            try {
                // Use the pinpointed coordinates
                const lat = selectedLocation.lat;
                const lng = selectedLocation.lng;

                addStatusMessage(`Using pinpointed coordinates: ${lat.toFixed(6)}, ${lng.toFixed(6)}`, 'info');

                // Step 1: Get building insights
                addStatusMessage('Analyzing building solar potential...', 'info');
                const buildingInsights = await getBuildingInsights(lat, lng);

                // Step 2: Get imagery data
                addStatusMessage('Fetching roof imagery...', 'info');
                const imageryData = await getImageryData(lat, lng);

                // Step 3: Calculate results
                const results = calculateSolarMetrics(buildingInsights, imageryData, {
                    panelPower,
                    panelWidth,
                    panelHeight,
                    address: `${lat.toFixed(6)}, ${lng.toFixed(6)}`,
                    lat: lat,
                    lng: lng
                });

                displayResults(results);
                addStatusMessage('Analysis complete!', 'success');

            } catch (error) {
                addStatusMessage(`Error: ${error.message}`, 'error');
            } finally {
                document.getElementById('loading').classList.add('hidden');
            }
        }

        async function geocodeAddress(address) {
            const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(address)}&key=${GOOGLE_API_KEY}`;

            try {
                const response = await fetch(url);
                const data = await response.json();

                if (data.status === 'OK' && data.results.length > 0) {
                    const result = data.results[0];
                    return {
                        success: true,
                        lat: result.geometry.location.lat,
                        lng: result.geometry.location.lng,
                        formattedAddress: result.formatted_address
                    };
                } else {
                    return {
                        success: false,
                        error: `Geocoding failed: ${data.status}`
                    };
                }
            } catch (error) {
                return {
                    success: false,
                    error: `Network error: ${error.message}`
                };
            }
        }

        async function getBuildingInsights(lat, lng) {
            // Try HIGH, MEDIUM, then BASE (experimental) quality levels
            const qualityLevels = ['HIGH', 'MEDIUM', 'BASE'];

            for (const quality of qualityLevels) {
                try {
                    let response, data;

                    if (quality === 'BASE') {
                        // For BASE quality, route through server to avoid CORS
                        const url = `/api/solar/building-insights`;
                        response = await fetch(url, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ lat, lng })
                        });
                    } else {
                        // For HIGH and MEDIUM quality, use GET request
                        const url = `https://solar.googleapis.com/v1/buildingInsights:findClosest?location.latitude=${lat}&location.longitude=${lng}&requiredQuality=${quality}&key=${GOOGLE_API_KEY}`;
                        response = await fetch(url);
                    }

                    data = await response.json();

                    if (response.ok) {
                        const qualityInfo = quality === 'HIGH' ? '0.1m/pixel aerial' :
                                          quality === 'MEDIUM' ? '0.25m/pixel aerial' :
                                          '0.25m/pixel satellite (experimental)';
                        addStatusMessage(`Found solar data (${quality} quality - ${qualityInfo})`, 'success');
                        // If server response, extract data property; otherwise use data directly
                        return data.data || data;
                    } else if (data.error?.message?.includes('not found') && quality !== 'BASE') {
                        addStatusMessage(`${quality} quality data not available, trying ${quality === 'HIGH' ? 'MEDIUM' : 'BASE (experimental)'}...`, 'info');
                        continue;
                    } else {
                        throw new Error(`Solar API error: ${data.error?.message || response.status}`);
                    }
                } catch (error) {
                    if (quality === 'BASE') {
                        throw new Error(`Failed to get building insights: ${error.message}`);
                    }
                    continue;
                }
            }
        }

        async function getImageryData(lat, lng) {
            // Try HIGH, MEDIUM, then BASE (experimental) quality levels
            const qualityLevels = ['HIGH', 'MEDIUM', 'BASE'];

            for (const quality of qualityLevels) {
                try {
                    let response, data;

                    if (quality === 'BASE') {
                        // For BASE quality, route through server to avoid CORS
                        const url = `/api/solar/imagery`;
                        response = await fetch(url, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ lat, lng })
                        });
                    } else {
                        // For HIGH and MEDIUM quality, use GET request
                        const url = `https://solar.googleapis.com/v1/dataLayers:get?location.latitude=${lat}&location.longitude=${lng}&radiusMeters=100&requiredQuality=${quality}&key=${GOOGLE_API_KEY}`;
                        response = await fetch(url);
                    }

                    data = await response.json();

                    if (response.ok) {
                        addStatusMessage(`Retrieved imagery data (${quality} quality)`, 'success');
                        // If server response, extract data property; otherwise use data directly
                        return data.data || data;
                    } else if (data.error?.message?.includes('not found') && quality !== 'BASE') {
                        continue;
                    } else {
                        console.warn('Failed to get imagery data:', data.error?.message);
                        if (quality === 'BASE') return null;
                        continue;
                    }
                } catch (error) {
                    console.warn('Failed to get imagery data:', error.message);
                    if (quality === 'BASE') return null;
                    continue;
                }
            }
            return null;
        }

        function calculateSolarMetrics(buildingInsights, imageryData, config) {
            const panelArea = config.panelWidth * config.panelHeight; // mÂ²

            // Extract data from Solar API response
            const roofSegmentSummaries = buildingInsights.solarPotential?.roofSegmentStats || [];
            const solarPanels = buildingInsights.solarPotential?.solarPanels || [];
            const financialAnalyses = buildingInsights.solarPotential?.financialAnalyses || [];

            // Calculate totals
            let totalRoofArea = 0;
            let maxPanelCount = 0;
            let yearlyEnergyDcKwh = 0;

            roofSegmentSummaries.forEach(segment => {
                if (segment.stats) {
                    totalRoofArea += segment.stats.areaM2 || 0;
                }
            });

            // Find the best configuration from solar panels
            if (solarPanels.length > 0) {
                const bestPanel = solarPanels.reduce((best, panel) => {
                    return (panel.yearlyEnergyDcKwh || 0) > (best.yearlyEnergyDcKwh || 0) ? panel : best;
                });

                maxPanelCount = bestPanel.panelsCount || 0;
                yearlyEnergyDcKwh = bestPanel.yearlyEnergyDcKwh || 0;
            }

            // Calculate financial metrics
            let installationCost = 0;
            let annualSavings = 0;
            let paybackYears = 0;

            if (financialAnalyses.length > 0) {
                const bestFinancial = financialAnalyses[0];
                installationCost = bestFinancial.upfrontCost?.value || maxPanelCount * 1000; // Fallback estimate
                annualSavings = bestFinancial.savings?.savingsYear1?.value || yearlyEnergyDcKwh * 0.12; // Fallback rate
                paybackYears = installationCost / (annualSavings || 1);
            }

            // Environmental calculations
            const co2OffsetKg = yearlyEnergyDcKwh * 0.4; // kg CO2 per kWh
            const equivalentTrees = Math.round(co2OffsetKg / 21); // Average tree absorbs ~21kg CO2/year

            return {
                address: config.address,
                lat: config.lat,
                lng: config.lng,
                buildingArea: totalRoofArea,
                maxPanelCount: maxPanelCount,
                yearlyEnergyKwh: yearlyEnergyDcKwh,
                installationCost: installationCost,
                annualSavings: annualSavings,
                paybackYears: paybackYears,
                co2OffsetKg: co2OffsetKg,
                equivalentTrees: equivalentTrees,
                imageryUrls: imageryData && imageryData.rgbUrl ? [
                    { name: 'Roof Image', imageUrl: imageryData.rgbUrl }
                ] : [],
                rawBuildingInsights: buildingInsights,
                rawImageryData: imageryData
            };
        }

        function displayResults(results) {
            currentResults = results;

            // Location info
            document.getElementById('result-address').textContent = results.address;
            document.getElementById('result-coords').textContent = `${results.lat.toFixed(6)}, ${results.lng.toFixed(6)}`;
            document.getElementById('result-area').textContent = `${results.buildingArea.toFixed(1)} mÂ²`;

            // Solar potential
            document.getElementById('result-flux').textContent = 'Calculated from roof analysis';
            document.getElementById('result-panels').textContent = `${results.maxPanelCount} panels`;
            document.getElementById('result-energy').textContent = `${results.yearlyEnergyKwh.toFixed(0)} kWh/year`;

            // Financial
            document.getElementById('result-cost').textContent = `$${results.installationCost.toLocaleString()}`;
            document.getElementById('result-savings').textContent = `$${results.annualSavings.toFixed(0)}/year`;
            document.getElementById('result-payback').textContent = `${results.paybackYears.toFixed(1)} years`;

            // Environmental
            document.getElementById('result-co2').textContent = `${results.co2OffsetKg.toFixed(0)} kg/year`;
            document.getElementById('result-trees').textContent = `${results.equivalentTrees} trees`;

            // Display imagery
            displayImagery(results.imageryUrls);

            document.getElementById('results').style.display = 'block';
        }

        function displayImagery(imageryUrls) {
            const container = document.getElementById('imagery-container');

            if (!imageryUrls || imageryUrls.length === 0) {
                container.innerHTML = '<p>High-resolution imagery not available for this location</p>';
                return;
            }

            container.innerHTML = '';

            // Display roof image with zoom and download
            imageryUrls.forEach((layer, index) => {
                if (layer.imageUrl) {
                    const layerDiv = document.createElement('div');
                    layerDiv.style.marginBottom = '20px';

                    const header = document.createElement('div');
                    header.style.display = 'flex';
                    header.style.justifyContent = 'space-between';
                    header.style.alignItems = 'center';
                    header.style.marginBottom = '10px';

                    const label = document.createElement('h4');
                    label.textContent = layer.name || 'Roof Image';
                    label.style.margin = '0';
                    header.appendChild(label);

                    const downloadBtn = document.createElement('button');
                    downloadBtn.textContent = 'Download Image';
                    downloadBtn.style.padding = '8px 16px';
                    downloadBtn.style.fontSize = '14px';
                    downloadBtn.onclick = () => downloadImage(layer.imageUrl, 'roof-image.png');
                    header.appendChild(downloadBtn);

                    layerDiv.appendChild(header);

                    const imgContainer = document.createElement('div');
                    imgContainer.style.position = 'relative';
                    imgContainer.style.overflow = 'auto';
                    imgContainer.style.maxHeight = '600px';
                    imgContainer.style.border = '2px solid #ddd';
                    imgContainer.style.borderRadius = '8px';
                    imgContainer.style.cursor = 'zoom-in';

                    const img = document.createElement('img');
                    // Use server-side conversion for GeoTIFF images
                    img.src = `/api/convert-image?url=${encodeURIComponent(layer.imageUrl)}`;
                    img.alt = layer.name || 'Roof image';
                    img.style.width = '100%';
                    img.style.height = 'auto';
                    img.style.display = 'block';
                    img.style.transition = 'transform 0.2s';

                    let isZoomed = false;
                    imgContainer.onclick = () => {
                        if (!isZoomed) {
                            img.style.transform = 'scale(2)';
                            img.style.transformOrigin = 'top left';
                            img.style.cursor = 'zoom-out';
                            imgContainer.style.cursor = 'zoom-out';
                            isZoomed = true;
                        } else {
                            img.style.transform = 'scale(1)';
                            img.style.cursor = 'zoom-in';
                            imgContainer.style.cursor = 'zoom-in';
                            isZoomed = false;
                        }
                    };

                    img.onload = () => {
                        console.log(`Loaded ${layer.name || 'roof image'}`);
                    };
                    img.onerror = () => {
                        console.warn('Failed to load imagery layer:', layer);
                        img.style.display = 'none';
                        const errorMsg = document.createElement('p');
                        errorMsg.textContent = `Failed to load ${layer.name || 'imagery'}`;
                        errorMsg.style.color = '#666';
                        errorMsg.style.padding = '20px';
                        imgContainer.appendChild(errorMsg);
                    };

                    imgContainer.appendChild(img);
                    layerDiv.appendChild(imgContainer);

                    const instruction = document.createElement('p');
                    instruction.textContent = 'Click image to zoom in/out';
                    instruction.style.fontSize = '12px';
                    instruction.style.color = '#666';
                    instruction.style.marginTop = '8px';
                    instruction.style.textAlign = 'center';
                    layerDiv.appendChild(instruction);

                    container.appendChild(layerDiv);
                }
            });
        }

        async function downloadImage(imageUrl, filename) {
            try {
                const response = await fetch(`/api/convert-image?url=${encodeURIComponent(imageUrl)}`);
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                addStatusMessage('Image downloaded successfully', 'success');
            } catch (error) {
                addStatusMessage('Failed to download image', 'error');
                console.error('Download error:', error);
            }
        }

        function addStatusMessage(message, type) {
            const statusDiv = document.getElementById('status-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `status ${type}`;
            messageDiv.textContent = message;
            statusDiv.appendChild(messageDiv);
            statusDiv.scrollTop = statusDiv.scrollHeight;
        }

        function clearStatusMessages() {
            document.getElementById('status-messages').innerHTML = '';
        }

        function resetApp() {
            document.getElementById('results').style.display = 'none';
            document.getElementById('address-input').value = '';
            clearStatusMessages();
            currentResults = null;
            selectedLocation = null;

            // Remove marker
            if (marker) {
                marker.setMap(null);
                marker = null;
            }

            // Hide map
            document.getElementById('map').classList.remove('visible');
            document.getElementById('map-instructions').classList.remove('visible');

            // Disable analyze button
            document.getElementById('analyze-btn').disabled = true;
        }
    </script>

    <footer style="margin-top: 40px; padding: 20px; background-color: #f8f9fa; border-top: 1px solid #dee2e6;">
        <div style="max-width: 800px; margin: 0 auto;">
            <h5 style="color: #666; font-size: 14px; margin-bottom: 10px;">Changelog</h5>
            <div style="font-size: 12px; color: #888; line-height: 1.4;">
                <p><strong>v3.0</strong> (Latest) - Added interactive Google Maps with pinpoint location selection</p>
                <p><strong>v2.1</strong> - Fixed imagery display for BASE quality data, Added proper expanded coverage support</p>
                <p><strong>v2.0</strong> - Fixed expanded coverage API calls to use GET requests instead of POST</p>
                <p><strong>v1.1</strong> - Added Malaysian address support with expanded coverage</p>
                <p><strong>v1.0</strong> - Initial release with standard coverage support</p>
            </div>
            <p style="font-size: 11px; color: #aaa; margin-top: 10px;">Last updated: 2025-10-03 (Build: v3.0)</p>
        </div>
    </footer>
</body>
</html>